from datetime import datetime

from flask import Markup
from slugify import slugify
from flask_security import utils, current_user, RoleMixin, UserMixin
from flask_admin.contrib import sqla
from flask_sqlalchemy import SQLAlchemy
import flask_whooshalchemy
from wtforms.fields import PasswordField
from whoosh.analysis import StemmingAnalyzer
from markdown import markdown
from markdown.extensions.codehilite import CodeHiliteExtension
from markdown.extensions.fenced_code import FencedCodeExtension

#from . import app

db = SQLAlchemy()

# A simple table to map the many-to-many relationship between articles and tags
articles_tags = db.Table(
    'articles_tags',
    db.Column('tag_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True),
    db.Column('article_id', db.Integer, db.ForeignKey('articles.id'), primary_key=True),
    )


class Article(db.Model):
    '''
    Nine Columns are provided:
    Name    |   Description
    ________________________________
    id      |   Autogenerated identification number
    title   |   Title of the post
    slug    |   A valid slug to access the post, if 
    summary |   A 1-2 line caption of the post
    content |   The full content written in markdown
    last_mod_date|   Post publication time
    draft   |   Flag to make the post not accessible
    tags    |   Tags on the post
    authour |   Autoregistered based on the post creator
    '''
    
    
    __tablename__ = 'articles'
    __table_args__ = {'extend_existing': True}
    __searchable__ = ['title', 'summary', 'content']
    __analyzer__ = StemmingAnalyzer()
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    slug = db.Column(db.String(150))
    summary = db.Column(db.String(300))
    content = db.Column(db.Text, nullable=False)
    last_mod_date = db.Column(db.DateTime, default=datetime.date(datetime.utcnow()))
    draft = db.Column(db.Boolean, default=0)
    tags = db.relationship('Tag', secondary=articles_tags,
                           backref=db.backref('articles', lazy='dynamic'))
    authour = db.relationship('User', backref='articles', lazy='dynamic')

    def __repr__(self):
        return '<Article {}>'.format(self.title)
    
    def __init__(self, title, summary, content, id=None,
                draft=False, last_mod_date=None,
                slug=None, authour=None):
        if id:
            self.id=id
        self.title = title
        self.summary = summary
        self.content = content
        self.draft = draft
        self.authour = authour
        if last_mod_date:
            # Use the given date and time instead of todays's date
            self.last_mod_date = last_mod_date
        if slug:
            self.slug = slugify(slug)
        else:
            # generate slug from the title if slug is not stated
            self.slug = slugify(self.title)


    @classmethod
    def public(cls):
        # Gets only the published articles
        return(Article.query.filter(Article.draft==0))
    
    @classmethod
    def in_draft(cls):
        # Gets only the draft articles
        return(Article.query.filter(Article.draft==1))

    @property
    def html_content(self):
        ''' Converts the content markdown into a Jinja Safe HTML'''
        #Initialize the markdown extensions
        md_extn1 = CodeHiliteExtension()
        md_extn2 = FencedCodeExtension()
        html_content = markdown(self.content, extensions=[md_extn1, md_extn2])
        return Markup(html_content)

class Tag(db.Model):
    '''
    Consists of two columns: id, and name.
    A many to many ralationsip with the Article Model.
    '''
    __tablename__ = 'tags'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True)
    
    def __repr__(self):
        return '<Tag {}>'.format(self.name)

    def __init__(self, name):
        self.name = name.lower()

    def save(self):
        db.session.add(self)
        db.session.commit()
        return self


#---------- User Management---------------

# Create a table to support a many-to-many relationship between Users and Roles
roles_users = db.Table(
    'roles_users',
    db.Column('user_id', db.Integer(), db.ForeignKey('user.id')),
    db.Column('role_id', db.Integer(), db.ForeignKey('role.id'))
)


# Role class
class Role(db.Model, RoleMixin):
    '''
    Our Role has three fields, ID, name and description
    
    Four roles are provided here:
    Name        |       Description
    ________________________________
    Authour     |   Only write a new post and edit own post 
    Editor      |   Only edit all existing posts (Post Table)
    Registrar   |   Only register and delete user (User Table)
    Owner       |   Can make or mar anything and everything
    '''
    id = db.Column(db.Integer(), primary_key=True)
    name = db.Column(db.String(80), unique=True)
    description = db.Column(db.String(255))

    # __str__ is required by Flask-Admin, so we can have human-readable values
    # for the Role when editing a User.
    # If we were using Python 2.7, this would be __unicode__ instead.
    def __str__(self):
        return self.name

    # __hash__ is required to avoid the exception
    # TypeError: unhashable type: 'Role' when saving a User
    def __hash__(self):
        return hash(self.name)


# User class
class User(db.Model, UserMixin):
    '''
    Eight fields: id, username, email, password, active, confirmed_at, roles, 
    and articles_ids.
    The roles field represents a many-to-many relationship using the roles_users
    table. i.e, Each user may have no role, one role, or multiple roles.
    The articles_ids represent a one to many relationship, as each user can have
    many posts, but  one post can not be owned by many users
    '''
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(128), unique=True)
    password = db.Column(db.String(128))
    active = db.Column(db.Boolean(), default=True)
    confirmed_at = db.Column(db.DateTime(),
                            default = datetime.date(datetime.utcnow()))
    roles = db.relationship(
        'Role',
        secondary=roles_users,
        backref=db.backref('users', lazy='dynamic')
    )
    articles_ids = db.Column(db.Integer, db.ForeignKey('articles.id'))
    def __repr__(self):
        return '<User {}>'.format(self.username)
    
    def get_name(self):
        return self.username


# Customized User model for SQL-Admin
class UserAdmin(sqla.ModelView):

    # Don't display the password on the list of Users
    column_exclude_list = ('password',)

    # Don't include the standard password field when 
    # creating or editing a User (but see below)
    form_excluded_columns = ('password',)

    # Automatically display human-readable names for the current and
    # available Roles when creating or editing a User
    column_auto_select_related = True

    # Prevent administration of Users unless the currently logged-in
    # user has the 'Registrar' role
    def is_accessible(self):
        return current_user.has_role('Registrar')

    # On the form for creating or editing a User, don't display a field
    # corresponding to the model's password field.
    # There are two reasons for this. First, we want to encrypt the password
    # before storing in the database. Second, we want to use a password field
    # (with the input masked) rather than a regular text field.
    def scaffold_form(self):

        # Start with the standard form as provided by Flask-Admin. We've already
        # told Flask-Admin to exclude the password field from this form.
        form_class = super(UserAdmin, self).scaffold_form()

        # Add a password field, name it 'password2' and labeling it 'New Password'.
        form_class.password2 = PasswordField('New Password')
        return form_class

    # This callback executes when the user saves changes to a newly-created or
    # edited User -- before the changes are committed to the database.
    def on_model_change(self, form, model, is_created):

        # If the password field isn't blank...
        if len(model.password2):

            # Encrypt the new password prior to storing it in the database.
            # If the password field is blank,
            # the existing password in the database will be retained.
            model.password = utils.encrypt_password(model.password2)


# Customized Role model for SQL-Admin
class RoleAdmin(sqla.ModelView):

    # Prevent administration of Roles unless the currently logged-in user has the
    # 'Registrar' role
    def is_accessible(self):
        return current_user.has_role('Registrar')

class ArticleAdmin(sqla.ModelView):
    
    # Prevent administration of Post unless the currently logged-in user has the
    # 'Editor' role
    def is_accessible(self):
        return current_user.has_role('Editor')
    
class TagAdmin(sqla.ModelView):
    
    # Prevent administration of Tags unless the currently logged-in user has the
    # 'Editor' role
    def is_accessible(self):
        return current_user.has_role('Editor')
        